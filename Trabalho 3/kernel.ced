;
;
;************************************************************************************
;
;	Kernel do sistema - Parte 2 do Trabalho 2
;
;
;	Áreas de memória
;
;	8000 - FF7F		_KRN_INT
;					Área de Kernel para implementação dos alunos
;
;	FF80 - FFBF 		_IOAREA16
;					Area de perifericos, acessada na base 16 bits
;
;	FFC0 - FFFF		_IOAREA08
;					Area de perifericos, acessada na base 8 bits
;					
;*************************************************************************************

_APP:		equ	h0100
_KRN_INT:	equ	h8000
_IOAREA16:	equ	hFF80
_IOAREA08:	equ	hFFC0


;
;-------------------------------------------------------------------------------------
;	Área reservada para os periféricos
;-------------------------------------------------------------------------------------

; Acesso em 16 bits
ORG	_IOAREA16
	daw	[31]
IVET:	dw	0			; Vetor de interrupção

; Acesso em 8 bits
	org	_IOAREA08
	dab	[23]
TIMDT:	db	1			; Registro de programação do timer
INTS:	db	0			; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db	0			; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db	0			; Status do teclado
TECDT:	db	0			; Dado do teclado
VISOR:	dab	[36]			; Portas de acesso ao visor



		
	
;
;-------------------------------------------------------------------------------------
;	Area para o kernel
;	Inicialização (reset)
;	Implementacao dos tratadores de interrupcao
;	Funções para usa do aplicação
;-------------------------------------------------------------------------------------
ORG	_KRN_INT
Vet_0:	dw		_reset
Vet_1:	dw		_kbhit
Vet_2:	dw		_getchar
Vet_3:	dw		_putchar
Vet_4:	dw		_putmsg
Vet_5:	dw		_setcursor
Vet_6:	dw		_start
Vet_7:	dw		_ready
	
	daw		[2]
STACK:
	daw		[31]		; Área reservada para a pilha
CURSOR:	
	dw    		0		; Define a posição do cursor
TICK_COUNT:
	dw		0		; Contador do timer
TEMP:
	dw		0		; Variável temporária
TEMP_END:
	dw		0		; Variável temporária
COUNT_CURSOR:
	dw		0		; Contagem de tempo para o pisca do cursor
CURSOR_TIMER_MODE:
	dw		0		; Modo cursor exibido ou apagado
TIMER_CURSOR:
	dw		0		; Tempo para apagar ou ligar o cursor

;-------------------------------------------------------------------------------------
;	Código de RESET (BOOT) do processador/interrupção
;-------------------------------------------------------------------------------------
_reset:
	CLR	INTS
	CLR 	TECST
	CLR     TECDT
	CLR     INTE     
	MOV	#1,TIMDT
	MOV 	#STACK,R6
	MOV	#ISR,IVET
	MOV	#h81,INTE
	MOV     #0,CURSOR
	MOV 	#0,TICK_COUNT
	MOV	#0,COUNT_CURSOR
	MOV	#500,TIMER_CURSOR
	JSR 	R7,_clear_visor
	JMP	_APP
	
;-------------------------------------------------------------------------------------
_clear_visor:
	MOV #0,CURSOR
_clear_visor_step:	
	MOV CURSOR,R0
	CMP R0,#36
	BPL _fim_clear_visor	;COMPARA CURSOR COM 35, SE FOR POSITIVO PARA
	ADD #VISOR,R0
	MOV #' ',(R0)
	INC CURSOR
	JMP _clear_visor_step
_fim_clear_visor:
	MOV #0,CURSOR
	RTS R7


;-------------------------------------------------------------------------------------
;	BOOL kbhit(void)
;
;Funçao:
;	Informa se alguma tecla foi digitada.
;	Não bloqueia esperando pelo teclado.
;Retorna:
;	Se R0==0, não há tecla
;	Se R0!=0, há tecla
;-------------------------------------------------------------------------------------
_kbhit:
	CMP	TECST,#H80
	BNE     kbhit_false
	JMP 	kbhit_true
kbhit_true:
	MOV 	#1,R0
	JMP     kbhit_fim
kbhit_false:
	MOV	#0,R0
kbhit_fim:
	RTS	R7

	
;-------------------------------------------------------------------------------------
;	CHAR	getchar(void)
;
;Funçao:
;	Bloqueia aguardando que alguma tecla seja digitada.
;	Se já houver uma tecla digitada, retorna a tecla imediatamente.
;	Essa função não coloca os caracteres digitados no visor.
;Retorna:
;	R0 == tecla digitada
;-------------------------------------------------------------------------------------
_getchar:
	JSR	R7,aux_getchar
	MOV	TECDT,R0
	CLR 	TECDT
	RTS	R7

aux_getchar:
	CMP	TECST,#H80
	BNE	aux_getchar
	CLR	TECST
	RTS	R7
;-------------------------------------------------------------------------------------
;	VOID	putchar(char)
;
;Funçao:
;	Escreve um caractere no visor, na posição do cursor.
;	Incrementa a posição do cursor, se for um caractere visível.
;		-> Se a posição do cursor for maior do que 35, o cursor deve desaparecer.
;	Decrementa a posição do cursor, se o caractere for um BS (Back-Space, ASCII H08).
;		-> Ignora o BS, caso a posição do cursor seja 0
;	
;Entra:
;	R0 == código ASCII do caractere a ser colocado no visor
;-------------------------------------------------------------------------------------
_putchar:
	CLR	INTE			;Para interrupção
	MOV     R0,TEMP
	CMP 	R0,#8			;Compara o caractere enviado com Backspace
	BEQ	_putchar_backspace
	JMP 	_putchar_no_backspace
_putchar_backspace:
	JMP	_putchar_backspace_pt_2
_putchar_no_backspace:
	CMP 	CURSOR,#36		;Verifica se o Cursor alcancou seu limite
	BPL	_putchar_end_cursor
	JMP	_putchar_pt_2
_putchar_end_cursor:
	JMP	_putchar_end	
_putchar_pt_2:
	MOV    	CURSOR,R0
	ADD     #VISOR,R0
	MOV     TEMP,(R0)
	INC 	CURSOR
	CMP 	CURSOR,#36		;Verifica se irá desenhar o cursor
	BPL	_putchar_pt_2_end_cursor
	JMP	_putchar_print_end
_putchar_pt_2_end_cursor:
	JMP	_putchar_end		
_putchar_backspace_pt_2:
	MOV    	CURSOR,R0
	ADD     #VISOR,R0
	MOV	#' ',(R0)
	DEC	CURSOR
	JMP	_putchar_print_end		
_putchar_erase_backspace:
	MOV	#' ',(R0)
	JMP	_putchar_end
_putchar_print_end:
	MOV    	CURSOR,R0
	ADD     #VISOR,R0
	MOV 	#'_',(R0)
	JMP	_putchar_end	
_putchar_end:
	MOV	#h81,INTE
	RTS	R7			;Ativa interrupção	

	
;-------------------------------------------------------------------------------------
;	VOID	putmsg(char *)
;
;Funçao:
;	Escreve um string no visor, a partir da posição do cursor.
;	Um string é uma sequencia de bytes terminada pelo byte H00.
;	Ajusta o cursor, para cada caractere do string, da mesma forma como descrito na função putchar.
;Entra:
;	R0 == endereço do string
;-------------------------------------------------------------------------------------
_putmsg:	
	MOV     R0,TEMP_END
_putmsg_loop:
	MOV 	TEMP_END,R0
	DEC	R0
	MOV     (R0),R0
	AND	#h00ff,R0
	TST     R0
	BEQ	_putmsg_fim
	JSR     R7,_putchar
	INC     TEMP_END
	JMP 	_putmsg_loop
_putmsg_fim:
	RTS	R7

	
;-------------------------------------------------------------------------------------
;	void setcursor(short pos)
;
;Funçao:
;	Altera a posição do cursor, representado pelo caractere “_”.
;	Para isso, apaga o cursor da sua posição atual no visor e escreve o cursor na nova posição.
;	Caso o novo valor seja maior do que 35, o cursor deverá “desaparecer”.
;Entra:
;	R0 = nova posição do cursor
;-------------------------------------------------------------------------------------
_setcursor:
	MOV	R0,TEMP
	MOV	CURSOR,R0
	CMP	R0,#36
	BPL	_setcursor_pt_2	;COMPARA CURSOR COM 35, SE FOR POSITIVO PARA
	ADD	#VISOR,R0
	MOV	#0,(R0)
_setcursor_pt_2:
	MOV 	TEMP,R0
	CMP	R0,#36
	BPL	_setcursor_fim	;COMPARA CURSOR COM 35, SE FOR POSITIVO PARA
	ADD	#VISOR,R0
	MOV	#'_',(R0)
_setcursor_fim:
	MOV 	TEMP,CURSOR
	RTS	R7
		

		
;-------------------------------------------------------------------------------------
;	void	start (short valor)
;
;Funçao:
;	Inicializa uma temporização
;	Se for chamada, novamente, antes do tempo atingir o seu final, um novo tempo será programado.
;	Essa função deve ser usada em conjunto com a função _ready
;Entra:
;	R0 = valor do tempo, em milisegundos
;-------------------------------------------------------------------------------------
_start:
	MOV 	R0,TICK_COUNT	
	MOV	#h81,INTE
	RTS	R7

;-------------------------------------------------------------------------------------
;	bool ready(void)
;
;Funçao:
;	Informa se o tempo programado pela função _start esgotou-se.
;Retorna:
;	R0==0, se o tempo programado não se esgotou.
;	R0<>0, se o tempo programado estogou-se
;-------------------------------------------------------------------------------------
_ready:
	TST	TICK_COUNT
	BEQ	_ready_true
	JMP     _ready_false
_ready_true:
	MOV     #1,R0
	RTS	R7
_ready_false:
	MOV     #0,R0
	RTS	R7


;-------------------------------------------------------------------------------------
; Rotina de INTERRUPÇÃO
; Só será chamada se as interrupções estiverem habilitadas
ISR:
	MOV		R0,-(R6)	; Salva registradores na pilha
	MOV		R1,-(R6)
	MOV		R2,-(R6)
	MOV		R3,-(R6)
	MOV		R4,-(R6)
	MOV		R5,-(R6)

	MOV		INTS,R0		; Verifica se a interrupção é do TIMER
	AND		#1,R0
	BEQ		ISR_return_rec
	TST		TICK_COUNT
	BNE		ISRTim_dec
	JMP		ISR_2
ISRTim_dec:
	DEC		TICK_COUNT
	JMP 		ISR_2
ISR_return_rec:
	JMP		ISR_return
ISR_2:
	TST		CURSOR_TIMER_MODE
	BEQ		ERASE_CURSOR
	JMP		DRAW_CURSOR	
ERASE_CURSOR:
	INC		COUNT_CURSOR
	CMP		COUNT_CURSOR,TIMER_CURSOR
	BEQ		ERASE_CURSOR_END
	MOV    		CURSOR,R0
	ADD     	#VISOR,R0
	CMP		(R0),#'_'
	BEQ		ERASE_CURSOR_2
	JMP		ISR_return
ERASE_CURSOR_END:
	MOV		#1,CURSOR_TIMER_MODE
	MOV		#0,COUNT_CURSOR
	JMP		ISR_return
ERASE_CURSOR_2:
	MOV		#' ',(R0)
	JMP		ISR_return
DRAW_CURSOR:
	INC		COUNT_CURSOR
	CMP		COUNT_CURSOR,TIMER_CURSOR
	BEQ		DRAW_CURSOR_END	
	MOV    		CURSOR,R0
	ADD     	#VISOR,R0
	CMP		(R0),#' '
	BEQ		DRAW_CURSOR_2
	JMP		ISR_return
DRAW_CURSOR_END:
	MOV		#0,CURSOR_TIMER_MODE
	MOV		#0,COUNT_CURSOR
	JMP		ISR_return
DRAW_CURSOR_2:
	MOV		#'_',(R0)
	JMP		ISR_return
ISR_return:
	AND		#hFFFE,INTS	; Desliga bit de interrupção TIMER
	MOV		(R6)+,R5	; Retorna os registradores da pilha
	MOV		(R6)+,R4	
	MOV		(R6)+,R3
	MOV		(R6)+,R2
	MOV		(R6)+,R1
	MOV		(R6)+,R0

	RTI				; Return From Interrupt				
		
		
;
;**************************************************************************************************
	

